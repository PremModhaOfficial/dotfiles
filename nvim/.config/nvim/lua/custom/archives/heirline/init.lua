-- return {
-- 	"rebelot/heirline.nvim",
-- 	config = function()
-- 		local conditions = require("heirline.conditions")
-- 		local utils = require("heirline.utils")
-- 		local Align = { provider = "%=" }
-- 		local Space = { provider = " ", highlight = utils.get_highlight("NonText") }
-- 		local colors = {
-- 			bright_bg = utils.get_highlight("Folded").bg,
-- 			bright_fg = utils.get_highlight("Folded").fg,
-- 			red = utils.get_highlight("DiagnosticError").fg,
-- 			dark_red = utils.get_highlight("DiffDelete").bg,
-- 			green = utils.get_highlight("String").fg,
-- 			blue = utils.get_highlight("Function").fg,
-- 			gray = utils.get_highlight("NonText").fg,
-- 			orange = utils.get_highlight("Constant").fg,
-- 			purple = utils.get_highlight("Statement").fg,
-- 			cyan = utils.get_highlight("Special").fg,
-- 			diag_warn = utils.get_highlight("DiagnosticWarn").fg,
-- 			diag_error = utils.get_highlight("DiagnosticError").fg,
-- 			diag_hint = utils.get_highlight("DiagnosticHint").fg,
-- 			diag_info = utils.get_highlight("DiagnosticInfo").fg,
-- 			git_del = utils.get_highlight("diffDeleted").fg,
-- 			git_add = utils.get_highlight("diffAdded").fg,
-- 			git_change = utils.get_highlight("diffChanged").fg,
-- 		}
--
-- 		local ViMode = {
-- 			-- get vim current mode, this information will be required by the provider
-- 			-- and the highlight functions, so we compute it only once per component
-- 			-- evaluation and store it as a component attribute
-- 			init = function(self)
-- 				self.mode = vim.fn.mode(1) -- :h mode()
-- 			end,
-- 			-- Now we define some dictionaries to map the output of mode() to the
-- 			-- corresponding string and color. We can put these into `static` to compute
-- 			-- them at initialisation time.
-- 			static = {
-- 				mode_names = { -- change the strings if you like it vvvvverbose!
-- 					n = "Normal",
-- 					no = "N?",
-- 					nov = "N?",
-- 					noV = "N?",
-- 					["no\22"] = "N?",
-- 					niI = "Ni",
-- 					niR = "Nr",
-- 					niV = "Nv",
-- 					nt = "Nt",
-- 					v = "Visual",
-- 					vs = "Vs",
-- 					V = "V-Line",
-- 					Vs = "Vs",
-- 					["\22"] = "V-Block",
-- 					["\22s"] = "V-Block",
-- 					s = "Select",
-- 					S = "S-Line",
-- 					["\19"] = "S-Block",
-- 					i = "Insert",
-- 					ic = "Insert",
-- 					ix = "Insert",
-- 					R = "Replace",
-- 					Rc = "Replace",
-- 					Rx = "Replace",
-- 					Rv = "V-Replace",
-- 					Rvc = "V-Replace",
-- 					Rvx = "V-Replace",
-- 					c = "Command",
-- 					cv = "Ex",
-- 					r = "Prompt",
-- 					rm = "More",
-- 					["r?"] = "Confirm",
-- 					["!"] = "Shell",
-- 					t = "Terminal",
-- 				},
-- 				mode_colors = {
-- 					n = "red",
-- 					i = "green",
-- 					v = "cyan",
-- 					V = "cyan",
-- 					["\22"] = "cyan",
-- 					c = "orange",
-- 					s = "purple",
-- 					S = "purple",
-- 					["\19"] = "purple",
-- 					R = "orange",
-- 					r = "orange",
-- 					["!"] = "red",
-- 					t = "red",
-- 				},
-- 			},
-- 			-- We can now access the value of mode() that, by now, would have been
-- 			-- computed by `init()` and use it to index our strings dictionary.
-- 			-- note how `static` fields become just regular attributes once the
-- 			-- component is instantiated.
-- 			-- To be extra meticulous, we can also add some vim statusline syntax to
-- 			-- control the padding and make sure our string is always at least 2
-- 			-- characters long. Plus a nice Icon.
-- 			provider = function(self)
-- 				return "%2( [" .. self.mode_names[self.mode] .. "] %)"
-- 				-- return " %2( [" .. self.mode_names[self.mode] .. "] %)"
-- 			end,
-- 			-- Same goes for the highlight. Now the foreground will change according to the current mode.
-- 			hl = function(self)
-- 				local mode = self.mode:sub(1, 1) -- get only the first mode character
-- 				return { fg = self.mode_colors[mode], bold = false }
-- 			end,
-- 			-- Re-evaluate the component only on ModeChanged event!
-- 			-- Also allows the statusline to be re-evaluated when entering operator-pending mode
-- 			update = {
-- 				"ModeChanged",
-- 				pattern = "*:*",
-- 				callback = vim.schedule_wrap(function()
-- 					vim.cmd("redrawstatus")
-- 				end),
-- 			},
-- 		}
--
-- 		local FileNameBlock = {
-- 			-- let's first set up some attributes needed by this component and its children
-- 			init = function(self)
-- 				self.filename = vim.api.nvim_buf_get_name(0)
-- 			end,
-- 		}
-- 		-- We can now define some children separately and add them later
--
-- 		local FileIcon = {
-- 			init = function(self)
-- 				local filename = self.filename
-- 				local extension = vim.fn.fnamemodify(filename, ":e")
-- 				self.icon, self.icon_color =
-- 					require("nvim-web-devicons").get_icon_color(filename, extension, { default = true })
-- 			end,
-- 			provider = function(self)
-- 				return self.icon and (self.icon .. " ")
-- 			end,
-- 			hl = function(self)
-- 				return { fg = self.icon_color }
-- 			end,
-- 		}
--
-- 		local FileName = {
-- 			init = function(self)
-- 				self.lfilename = vim.fn.fnamemodify(self.filename, ":.")
-- 				if self.lfilename == "" then
-- 					self.lfilename = "[No Name]"
-- 				end
-- 			end,
-- 			hl = { fg = utils.get_highlight("Directory").fg },
--
-- 			flexible = 2,
--
-- 			{
-- 				provider = function(self)
-- 					return self.lfilename
-- 				end,
-- 			},
-- 			{
-- 				provider = function(self)
-- 					return vim.fn.pathshorten(self.lfilename)
-- 				end,
-- 			},
-- 		}
--
-- 		local FileFlags = {
-- 			{
-- 				condition = function()
-- 					return vim.bo.modified
-- 				end,
-- 				provider = "[+]",
-- 				hl = { fg = "green" },
-- 			},
-- 			{
-- 				condition = function()
-- 					return not vim.bo.modifiable or vim.bo.readonly
-- 				end,
-- 				provider = "",
-- 				hl = { fg = "orange" },
-- 			},
-- 		}
--
-- 		-- Now, let's say that we want the filename color to change if the buffer is
-- 		-- modified. Of course, we could do that directly using the FileName.hl field,
-- 		-- but we'll see how easy it is to alter existing components using a "modifier"
-- 		-- component
--
-- 		local FileNameModifer = {
-- 			hl = function()
-- 				if vim.bo.modified then
-- 					-- use `force` because we need to override the child's hl foreground
-- 					return { fg = "cyan", bold = true, force = true }
-- 				end
-- 			end,
-- 		}
--
-- 		-- let's add the children to our FileNameBlock component
-- 		FileNameBlock = utils.insert(
-- 			FileNameBlock,
-- 			FileIcon,
-- 			utils.insert(FileNameModifer, FileName), -- a new table where FileName is a child of FileNameModifier
-- 			FileFlags,
-- 			{ provider = "%<" } -- this means that the statusline is cut here when there's not enough space
-- 		)
--
-- 		local GitBranch = {
-- 			condition = conditions.is_git_repo,
-- 			provider = function()
-- 				return " " .. vim.b.gitsigns_head .. " "
-- 			end,
-- 			hl = {
-- 				fg = colors.bright_bg,
-- 				bg = colors.git_branch,
-- 				bold = true,
-- 			},
-- 		}
--
-- 		-- We're getting minimalist here!
-- 		local Ruler = {
-- 			-- %l = current line number
-- 			-- %L = number of lines in the buffer
-- 			-- %c = column number
-- 			-- %P = percentage through file of displayed window
-- 			provider = "%7(%l/%3L%):%2c %P",
-- 		}
-- 		local ScrollBar = {
-- 			static = {
-- 				-- sbar = { "▁", "▂", "▃", "▄", "▅", "▆", "▇", "█" },
-- 				-- Another variant, because the more choice the better.
-- 				sbar = { "🭶", "🭷", "🭸", "🭹", "🭺", "🭻" },
-- 			},
-- 			provider = function(self)
-- 				local curr_line = vim.api.nvim_win_get_cursor(0)[1]
-- 				local lines = vim.api.nvim_buf_line_count(0)
-- 				local i = math.floor((curr_line - 1) / lines * #self.sbar) + 1
-- 				return string.rep(self.sbar[i], 2)
-- 			end,
-- 			hl = { fg = "blue", bg = "bright_bg" },
-- 		}
-- 		local LSPActive = {
-- 			condition = conditions.lsp_attached,
-- 			update = { "LspAttach", "LspDetach" },
--
-- 			-- You can keep it simple,
-- 			-- provider = " [LSP]",
--
-- 			-- Or complicate things a bit and get the servers names
-- 			provider = function()
-- 				local names = {}
-- 				for i, server in pairs(vim.lsp.get_clients({ bufnr = 0 })) do
-- 					table.insert(names, server.name)
-- 				end
-- 				return " [" .. table.concat(names, " ") .. "]"
-- 			end,
-- 			hl = { fg = "green", bold = true },
-- 		}
--
-- 		local WorkDir = {
-- 			init = function(self)
-- 				self.icon = (vim.fn.haslocaldir(0) == 1 and "l" or "g") .. " " .. " "
-- 				local cwd = vim.fn.getcwd(0)
-- 				self.cwd = vim.fn.fnamemodify(cwd, ":~")
-- 			end,
-- 			hl = { fg = "blue", bold = true },
--
-- 			flexible = 1,
--
-- 			{
-- 				-- evaluates to the full-lenth path
-- 				provider = function(self)
-- 					local trail = self.cwd:sub(-1) == "/" and "" or "/"
-- 					return self.icon .. self.cwd .. trail .. " "
-- 				end,
-- 			},
-- 			{
-- 				-- evaluates to the shortened path
-- 				provider = function(self)
-- 					local cwd = vim.fn.pathshorten(self.cwd)
-- 					local trail = self.cwd:sub(-1) == "/" and "" or "/"
-- 					return self.icon .. cwd .. trail .. " "
-- 				end,
-- 			},
-- 			{
-- 				-- evaluates to "", hiding the component
-- 				provider = "",
-- 			},
-- 		}
--
-- 		local StatusLine = {
-- 			ViMode,
-- 			Space,
-- 			Align,
-- 			LSPActive,
-- 			Space,
-- 			GitBranch,
-- 			Space,
-- 			WorkDir,
-- 			Space,
-- 			Ruler,
-- 			Space,
-- 			ScrollBar,
-- 			{ grow = true },
-- 		}
--
-- 		local hline = require("heirline")
-- 		hline.load_colors(colors)
-- 		hline.setup({
-- 			statusline = StatusLine,
-- 			opts = {
-- 				colors = colors,
-- 			},
-- 		})
-- 	end,
-- 	dependencies = {},
-- }
--
--
return {
	"rebelot/heirline.nvim",
	lazy = true,
	config = function()
		local statu_scolumn = require("custom.ui_plugs.heirline.statuscolumn")
		local status_line = require("custom.ui_plugs.heirline.statusline")
		require("heirline").setup({
			statusline = status_line,
			statuscolumn = statu_scolumn,
		})
	end,
}
